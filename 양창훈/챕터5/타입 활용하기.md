
# 조건부 타입

타입스크립트의 조건부 타입은 자바스크립트의 삼항 연산자와 동일한 형태를 가진다.

조건부 타입의 장점은
중복되는 타입 코드를 제거 가능하며 상황에 따라 적절한 타입을 얻어 정확한 타입 추론이 가능하다.

##  extends와 제네릭을 활용한 조건부 타입

```ts
T extends U ? X : Y
// 타입 T를 U에 할당할 수 있으면 X 타입
// 타입 T를 U에 할당할 수 없으면 Y 타입
```

## 조건부 타입을 사용하지 않았을때의 문제점

**아래는 예시**
```ts
interface PayMethodBaseFromRese{
  // 서버에서 받아오는 결제 수단 기본 타입
}

interface Bank extends PayMethodBaseFromRes {
  //
}

interface Card extends PayMethodBaseFromRese {
  // 은행과 카드 각각에 맞는 결제 수단 타입
}

type PayMethodInfo<T extends Bank | Card> = T & PayMethodInterface; ////최종 은행,카드 결제 수단 타입으로 프론트에서 추가되는 UI 데이터 타입과 제네릭으로 받아오는 Bank 또는 Card를 합성한다.
type PayMethodInterface {
  companyName: string;
  ... // 프론트에서 관리하는 결제 수단 관련 데이터로 UI를 구현하는 데 사용되는 타입
}


  //useGetRegsteredList함수는 useQuery의 반환 값을 돌려준다
  // useCommonQuery<T>는 useQuery를 한 번 래핑해서 사용하고 있는 함수로 useQuery의 반환 data를 T타입으로 반환한다.
  // fetcherFactory는 axios를 래핑해주는 함수이며, 서버에서 데이터를 받아온 후 on-success 콜백 함수를 거친 결괏값을 반환한다.

type PayMethodType = PayMethodInfo<Card> || PayMethodInfo<Bank>;

export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {

  const url = `baeminpay/codes/${type === "appcard" ? "card" : type}`;

  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess: (res) =>{
      const usablePocketList =
        res?.filer(
          (pocket:PocketInfo<Card> | PocketInfo<Bank>) =>
            pocket?.useType === "USE
        ) ?? [];
          return useablePocketList;
    }
  })




  const result = useCommonQuery<PayMethodType[]>(url, undefiend, fetcher) // useQuery를 래핑해 사용하는 함수로 반환 data를 T타입으로 변환함
  return
}


```

위 코드는 계좌,카드,앱카드 3가지 결제수단이 있고 해당 타입에 맞는 서버 응답을 처리하는 함수이다.

위 코드의 의도로는 인자를 받는 타입에 따라 반환값 역시 해당 타입에 맞게 반환하기를 원하지 않았나 싶다.

하지만 반환 타입이 PayMethodType으로 유니온 타입이다. 반환 타입이 유니온(|)이라서 인자별로 타입이 구분되지 않아 원하는 결과가 아니다! 아마도? 맞나 ?



이처럼 "인자"에 맞게 반환되는 타입을 다르게 설정하고싶다면 extends를 사용한 조건부 타입을 활용하면 된다

그니까 위의 코드의 의도는 "card" | "appcard" | "bank" 를 인자로 넣는다
그리고 반환값들의 타입도 그에 맞게 card,appcard,bank []로 넣고 싶어하는거 같다.
근데 PayMethodType은 유니온 타입으로 중복으로 타입을 받을 수 있따.



## extends 조건부 타입을 활용하여 개선

```ts
type PayMethodType<T extends "card" | "appcard" | "bank"> = T extends "card" | "appcard" ? Card : Bank;

으로 extends 조건부 사용하고
export const useGetRegisteredList = <T extends "card" | "appcard" | "bank">(
  type: T
): UseQueryResult<PayMethodType<T>[]> => {

  const url = `baeminpay/codes/${type === "appcard" ? "card" : type}`;

  const fetcher = fetcherFactory<PayMethodType<T>[]>({  // 여기도 T 적용
    onSuccess: (res) => {
      const usablePocketList =
        res?.filter(  // filer → filter
          (pocket: PayMethodType<T>) =>  // 타입도 T 적용
            pocket?.useType === "USE"
        ) ?? [];
      return usablePocketList;
    }
  });

  const result = useCommonQuery<PayMethodType<T>[]>(url, undefined, fetcher);
  return result;  // result 추가
}
```
**유니온 타입으로는 인자별 타입 분기 불가능 → 조건부 타입으로 해결**



## infer 활용해서 타입 추론하기

infer은 항 연산자를 사용한 조건문의 형태를 가지는데, extends로 조건을 서술하고 infer로 타입을 추론하는 바익을 취한다.

```ts
type UnpackPromise<T> = T extends Promise<infer K>[] ? K :any;

UnpackPromise 타입은 제네릭으로 T를 받아서 T가 Promise로 래핑된 경우라면 K 반환 아니면 any를 반환

즉 Promise의 반환 값을 추론해서 해당 값의 타입을 K로 한다는 의미임


const promise = [Promise.reslove("Mark"),Promise.resolve(38)]

type exepctType = UnpackPromise<typeof promise>
```

그럼 패턴<infer K>이런식인가 ?

infer는 항상 extends 조건부 타입(삼항 연산자) 안에서만 사용됩니다!

type 타입이름<T> = T extends 패턴<infer 추론할변수> ? 참일때 : 거짓일때


```ts
//그럼 Array<infer K>[] ? K : any; 이러면
const array = [["hello",30,()=>{}],[30,"20","20"]]

type UnpackArray<T> = T extends Array<infer K>[] ? K : any;

const array = [["hello", 30, () => {}], [30, "20", "20"]];

type Result = UnpackArray<typeof array>;
// Result = string | number | (() => void)

```

# 템플릿 리터럴 타입 활용하기

유니온 타입을 사용하여 변수 타입을 특정 문자열로 지정가능 그리고 타입확장 (불변성?)

```ts
type HeaderTag ="h1" | "h2" | "h3" ...

type HeadingNumber = 1 | 2 | 3 ...

type HeaderTage = `h${HeadingNumber}`;

=> type "h1" | "h2" | "h3" ...
//단순한 경우 사용 x
// 복잡한 경우 사용 ㄱㄱ
```


# 커스텀 유틸리티 타입 활용하기

## PickOne 유틸리티 함수

ts에서 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 진행되지 않는 이슈가 있다.

위 문제를 해결하기 위해
PickOne이라는 이름의 유틸리티 함수를 구현해보자

```ts

type Card = {
  card: string
};

type Account = {
  account: stirng
}
function withdraw(type: Card | Account){
  ...
}

withdraw({card:"hyundai", account:"hana"})
```
위 의 경우 유니온 타입으로 객체로 card속성과 account속성 둘중하나만 쓰거나 둘다 쓰는 것이 가능하다
하지만 원하는건 카드나 계좌 둘중 하나만 쓰이도록을 원한다.

이를 해결하기위해 식별할 수 있는 유니온기법을 사용한다

```ts
type Card = {
  type:"card";
  card: string
};

type Account = {
  type:"card";
  account: stirng
}
function withdraw(type: Card | Account){
  ...
}

withdraw({card:"hyundai", account:"hana"}) // 에러
withdraw({type:"account", account:"hana"}) //  ㄱㅊ

```

근데 위처럼 하면 일일이 type을 다 넣어줘야해서 불편할 수 있다.
**이런 상황을 방지하기 위해 PickOne을 구현해보자**

```ts
type PayMethod = {account:string; card?:undefined, payMoney?:undefined}|
                  {account?:undefined; card:string, payMoney?:undefined}|
                  {account?:undefined; card?:undefined, payMoney:string}|

// 를 아래 처럼 커스텀 유틸리티 타입 만들기기

type PickOne<T> = {
  [P in keyof T]: Record<P,T[P]> & Partial<Record<Exclude<keyof T,P>, undefined>>;
}[keyof T]


type PayMethod = PickOne<{
  account: string;
  card: string;
  payMoney: string;
}>;
```
**차례대로 풀어보자면...**
```ts
Record<account,string> & Partial<Record<{card,payMoney},undeifiend>;
▽
Record<account,string> & Partial<card:undefiend, payMoney:undeifend>
▽
Record<account,string> & {card?:undefiend, payMoney?:undefiend}

▽

// type PayMethod =
  | { account: string; card?: undefined; payMoney?: undefined }
  | { account?: undefined; card: string; payMoney?: undefined }
  | { account?: undefined; card?: undefined; payMoney: string };

```


### 잘몰라서 사용된 유틸리티 타입 정리..
```ts
// Record
// 키(K)와 값(T)으로 구성된 객체 타입을 생성합니다.
type User = Record<"name" | "age", string | number>;
// type User = {
  name: string | number;
  age: string | number;
}

// Exclude
// 타입 T에서 U를 제외(빼기)한 타입을 반환합니다.
type A = "a" | "b" | "c";
type B = Exclude<A, "b">;  // "a" | "c"

// particiaoil
// T의 모든 프로퍼티를 optional(?)로 바꿉니다.

type OptionalUser = Partial<User>;
// { name?: string; age?: number }



```


해당 커스텀 유틸리티 타입을 만들기 위해 작은 단위 타입인 One과 ExcludeOne 타입을 각각 구현한 뒤, 두 타입을 활용해 하나의 타입 PickOne을 표현한다.
작은 단위부터 단계별로 구현해 만든 타입 PickOne을 이용해 정확한 타입을 추론하도록 할 수 있다.

## NonNullable 타입 검사 함수를 사용하여 간편하게 타입 가드하기

Null을 가질 수 있는 값의 null처리는 자주 사용되는 타입 가드 패턴의 하나임.

NonNullable 타입이란
제네릭으로 받는 T가 null 또는 undefiend일때 never 또는 T를 반환하는 타입이다.
따라서 NULL이나 UNDEFIEND가 아닌 경우를 제외할 수 있따.

```ts
type NonNullable<T> = T extends null | undefiend ? never : T;

```

**null,undefiend를 검사해주는 NonNullable함수**

NonNuallable 함수는 매ㅐ변수인 value가 null 또는 undefiend를 검사해주는 타입 가드 함수를 만들 수 있다.


```ts
function NonNullable<T>(value:T): value is NonNullable<T> {
  return value !== null && value !== undefiend;
}
```
value가 null또는 undefiend라면 false를 반환하고 is 키워드를 사용하여 true가 반환된다면 넘겨준 인자는 null이나 undefiend가 아닌 타입으로 타입이 좁혀질 수 있따.


#불변 객체 타입으로 활용하기

프로젝트 진행시 상숫값을 관리할 때 객체를 사용할 수 있다.



# Record 원시 타입 키 개선하기

```ts
// Record
// 키(K)와 값(T)으로 구성된 객체 타입을 생성합니다.
type User = Record<"name" | "age", string | number>;
// type User = {
  name: string | number;
  age: string | number;
}
```

객체 선언 시 키가 어떤 값인지 명확하지 않다면 Record의 키를 string이나 number 같은 원시 타입으로 명시하곤 한다.

## 무한한 키를 집합으로 가지는 Record

다음은 음식 분류를 키로 사용하는 음식 배열이 담긴 객체를 만들었따
```ts
type Category = string;
interface Food{
  name:string;
}

const foodByCatergory: Record<Category,Food[]> = {
  한식: [{name: "제육"},{name: "뚝배기"},
  일식: [{name:"초밥"}, {name: "텐동"}]
}

```
위에서 카테고리 타입은 string이다.
근데 foodByCategory객체에 없는 키값을 사용하더라도 컴파일단계에선 타입스크립트는 오류를 표시하지 않는다 왜 ?

```ts
foodByCategory["양식"] // Food[]로 추론
foodByCategory["양식"].map((food)=.console.log(food.name))// 오류 x
```
그러나 foodByCategory["양식"]은 **런타임**에서 undefiend가 되어 오류를 반환한다

이때 옵셔널 체이닝을 사용해 런타임 에러를 방지할 수 잇따.


## 유닛 타입으로 변경하기
키가 유한한 집합이라면 유닛 타입을 사용할 수 있다.

```ts
type Category = "한식" | "일식";

interface Food {
  name: stirng;
}

const foodByCategory: Record<Category,Food[]> = {
  한식: ..
  일식: ..
}
```
이제 Category는 한식 또는 일식의 키만을 받을 수 있어 양식을 가져올 경우 타입 에러를 발생시킨다.

**근데 무한한 키를 가져야 하는 경우엔 적합하지 않는다.**


## Partial을 활용하여 정확한 타입 표현하기

키가 무한한 상황에서는 Partial을 사용하여 값이 undefiend일 수 잇는 상태임을 표현할 수 있다.

```ts
// partial
// T의 모든 프로퍼티를 optional(?)로 바꿉니다.

type OptionalUser = Partial<User>;
// { name?: string; age?: number }
```
```ts

type PartialRecord<K extends string, T> = partial<Record<K,T>>;
type category = string;

interface Food {
  name: stirng;
}

const foodCategory: PartialRecord<Category,Food[]> = {
  한식: [{...}]
  일식: [{...}]
}

foodByCategory["양식"] // Food[] 또는 undefiend로 타입 추론
foodByCategory["양식"].map(()=>console.log(food.name) // Object is possibly 'undefiend'
foodByCategory["양식"]?.map(()=>console.log(food.name) // OK
```
