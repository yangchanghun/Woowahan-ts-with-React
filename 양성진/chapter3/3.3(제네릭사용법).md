## 제네릭

```ts
type ExampleArrayType<T> = T[];

const stringArray:ExampleArrayType<string> = ['가','나','다']

```
사전적으로는 일반적인것,타입스크립트에서는 일반화된 데이터 타입을 뜻함.

내부적으로 사용할 타입을 정해두지 않고, 타입 변수를 사용해서, 실제로 사용시 그 값을 외부에서 타입변수자리에 지정하여 사용하는 방식.

여러타입에 대해 따로 입력할 필요가 없어서 재사용성이 크게 향상됨.


특정타입에서만 존재하는 멤버를 참조할수 없음.

없는 속성을 가져다 쓸수 없기때문에

```ts
function sampleFn1<T>(arg:T)T[]{
return arg.length // Error: 획일화된 타입. 제네릭 T에 length라는게 있는지 모르니까 사용할수 없음.
}
```

```ts
interface lengthType {
    length:number;
}
function sampleFn1<T extends lengthType>(arg:T)T[]{
return arg.length // length가 있는지 확인이 되니까 사용이 가능함.
}
```

### 주의할점.

파일 확장자가 tsx일때, 화살표 함수에 제네릭을 사용하면 에러가 발생함.

```tsx
const arrowFunction = <T>(arg:T):T[] =>{
    return new Array(3).fill(arg); // Error JSX element 'T' has no corresponding closing tag
};

const arrowFunction = <T extends {}>(arg:T):T[] =>{
    return new Array(3).fill(arg); // Ok
}

```

tsx는 타입스크립트 + JSX이므로 제네릭의 꺽쇠 괄호와 태그의 꺽쇠괄호를 혼동해서 문제가 생김.


## 제네릭 사용법

다양한 곳에서 사용할 수 있다.

### 1. 함수 제네릭

```ts
const arrowFunction = <T extends {}>(arg:T):T[] =>{
    return new Array(3).fill(arg); // Ok
}
```

매개 변수나 반환값에 다양한 타입을 넣고 싶을때 사용할 수 있다.

### 2. 호출 시그니처 제네릭

함수타입 문법으로, 매개변수와 반환 타입을 미리 선언하는것을 말함.

```ts
interface CallSignature<T> {
    getData: (id: string) => Promise<T>;  // T를 반환하도록 미리 선언
    processItem: (item: T) => T;          // T를 받아 T를 반환하도록 미리 선언
}

```

 
### 3. 제한된 제네릭

타입 매개변수에 제약조건을 거는 기능을 말함.

```ts
type 스트링만제약을거는타입<Key extends string> = {
  [K in Key]: string;
};

// 사용 예시
type UserFields = 스트링만제약을거는타입<"name" | "email" | "phone">;
// 결과: { name: string; email: string; phone: string; }

```

이처럼 타입 매개변수가 특정 타입으로 묶였을때, **키를 바운드 타입 매개변수라** 부름.
string을 **키의 상한 한계**라고 함.


### 4. 확장된 제네릭

여러 타입을 상속받을수 있으며, 타입 매개변수를 여러개 둘 수도 있다.

```ts
<key extends string>
```
이런 식으로 제약하면, 제네릭의 유연성을 잃어버림

```ts
<key extends string | number>
```

이럴땐 유니온 타입을 상속해서 선언하면 됨.

하지만 타입 매개변수가 여러개일때는 처리할수 없음.

이럴때는 매개변수를 하나 더 추가하여 선언한다.

```ts
// 여러 타입 매개변수 사용, 일부에만 제약 조건
function createRecord<T, U extends string>(data: T, key: U): Record<U, T> {
  return { [key]: data } as Record<U, T>;
}

// 사용 예시
const userRecord = createRecord(123, "userId");     // Record<"userId", number>
const nameRecord = createRecord("홍길동", "name");   // Record<"name", string>

```


