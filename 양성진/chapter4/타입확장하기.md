# 타입확장하기

## 타입확장

1. interface,type으로 정의하는것을 말한다.

2. extends,교차타입,유니온타입을 이용해 확장함.


### 타입확장의 장점

1. 코드의 중복을 줄일수 있다.

```ts
interface BaseMenuItem{
    itemName:string;
    itemImageUrl:string;
    stock:number;
}

// 수량정보 추가

interface CartItem extends BaseItem{
    quantity:number;
}

```

중복으로 작성하지 않고, 기존것에 externds로 확장. 코드가 간결해짐.
명시적으로도 확장되었다는게 눈에 보임.

interface대신 type을 쓴다면,

```ts
type BaseMenuItem = {
    itemName:string;
    itemImageUrl:string;
    stock:number;
};


type BaseItem ={
    quantity:number;
} & BaseMenuItem;
```

extends를 사용하지 않고, &으로 작성함.
extends 키워드는 interface 선언 시에만 직접 사용할 수 있습니다.

구분|	Interface|	Type|
---|-----------------|---------------
상속|	extends ✅ | extends ❌
교차| & ✅	| & ✅
선언 병합|	가능 ✅	|불가능 ❌




2. 명시적인 코드작성
3. 확장성: 요구사항이 늘어날때마다 확장하여 정의할수 있다.

예시로,

```ts
interface EditableItem extends BaseCactItem{
    isSoldOut: boolean;
    optionGroups: SelectionOptionGroup[];
}

// 주문 가능 여부를 추가

interface EventCartItem extends BaseCartItem{
    orderable:boolean
}

/**
 * BaseCartItem을 확장하여 만들수 있다.   
장바구니 관련한 타입들을 손쉽게 만들수 있다.   
기존 장바구니를 수정시에는 BaseCartItem을 수정하면 됨.
*/
```

### 유니온타입

```ts
type UnionType = A | B ;
```
- 2개 이상의 타입을 조합하여 사용한 방법이다(합집합)
- 예제를 보면서 이해가 안된건
```ts
interface Step1 {
  b: string;
  c: string;
  z: string;
}

interface Step2 {
  a: string;
  b: string;
  c: string;
  x: string;
}

function getStep(step: Step1 | Step2) {
  return step.a; // ❌ Error!
}
```
왜 a를 못불러올까?

 > 이게 합집합이면 둘다 리턴을 취할수 있지 않나?

흔히 수학적으로 아는 집합의 개념과 반대라고 생각하면 되는거 같습니다.

https://knowledge-powerful-but-harmful.tistory.com/244

AI를 통해서 정리해본 결과, 


### Union Type (A | B)

### 기본 개념

여러 타입 중 하나를 가질 수 있음     

- 값 할당: 합친 타입 중 아무거나 가능    
- 값 사용: 넓은 타입을 더 구체적인 타입으로 좁혀나가는 과정(타입좁히기) 후 사용 (공통 속성은 타입좁히기 불필요)

### 구조적 타이핑 관점의 핵심 ⭐
"합집합을 교집합처럼 생각하라"
```ts
interface Bird {
    fly(): void;
    layEggs(): void;
}

interface Fish {
    swim(): void;
    layEggs(): void;
}

function getSmallPet(): Fish | Bird {
    // Bird 또는 Fish 반환
}

const pet = getSmallPet();
pet.layEggs();  // ✅ 공통 속성만 사용 가능 (교집합)
pet.swim();     // ❌ 에러 - 어떤 타입인지 모름
```

**왜?** TypeScript는 반환된 값이 Bird인지 Fish인지 알 수 없으므로, 양쪽 모두 가진 속성(교집합)만 안전하게 사용 가능

### 교차 타입 (A & B)
### 기본 개념

여러 타입을 모두 만족하는 타입
모든 속성을 다 가져야 함

### 구조적 타이핑 관점의 핵심 ⭐
"교집합을 합집합처럼 생각하라"
 
```typescript
type Person = { name: string };
type Employee = { employeeId: number };

type EmployeeDetails = Person & Employee;  // 둘 다 필요 (합집합)

const employee: EmployeeDetails = {
    name: "John",
    employeeId: 12345
};
```
**왜?** 양쪽 타입 모두에 속하려면 모든 속성(합집합)을 가져야 어느 쪽으로 간주해도 문제없음

### extends와 교차타입.

extends를 통해서도 교차 타입을 작성할 수도 있다.

위에서 설명을 해서 추가로 주의점만 설명.

```ts
interface DeliveryTip{
    tip:number;
}

interface Filter extends DeliveryTip{
    tip:string;
}

// ❌ 
```

extends로 타입 확장하면, 타입이 중복되면 안됨.

하지만,
```ts
type DeliveryTip = {
    tip:number;
}

type Filter = DeliveryTip{
    tip:string;
}

```
type으로 바꾸면 됨.

이때 tip속성의 타입은 string이나 number가 아닌 **never**

**왜?**

type키워드는 교차로 선언되었을시 새롭게 속성이 추가된건 속성을 미리 알 수 없기에 선언시 에러가 발생하지 않는다. tip은 같은 속성에 대해 서로 호환되 않는 타입이 선언되서 never타입이 됨.


### 타입 좁히기 - 타입 가드.

